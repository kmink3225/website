---
title: "Data Preparation"
subtitle: "Simulation"
description: ""
author: Kwangmin Kim
date: 2022-12-20
image: images/high_dimensions.jpg
image-alt: "a high dimensional data"
format:
  html:
    code-fold: true
    code-summary: "Show the code"
execute:
  warning: false
# ---
# title: "Comparative Study of Dimension Reduction Methods"
# subtitle: "Statistics and Machine Learning"
# description: "Due to security concerns, it is difficult to display the data used in this project. Therefore, I will generate fake data to reproduce and demonstrate a rough analysis pipeline."
# author: Kwangmin Kim
# date: 2022-12-20
# image: images/high_dimensions.jpg
# image-alt: "a high dimensional data"
# format:
#   html:
#     code-fold: true
#     code-summary: "Show the code"
# execute:
#   warning: false
# ---  
---


<ul class="nav nav-pills" id="language-tab" role="tablist">
  <li class="nav-item" role="presentation">
    <button class="nav-link active" id="Korean-tab" data-bs-toggle="tab" data-bs-target="#Korean" type="button" role="tab" aria-controls="Korean" aria-selected="true">Korean</button>
  </li>
  <li class="nav-item" role="presentation">
    <button class="nav-link" id="English-tab" data-bs-toggle="tab" data-bs-target="#English" type="button" role="tab" aria-controls="knitr" aria-selected="false">English</button>
  </li>

<div class="tab-content" id="language-tabcontent">

<div class="tab-pane fade  show active" id="Korean" role="tabpanel" aria-labelledby="Korean-tab">



</div>

<div class="tab-pane fade" id="English" role="tabpanel" aria-labelledby="English-tab">





## Introduction

### Background

Alzheimer Disease (AD) is a most common form of dementia that affects millions of Americans. AD affects memory, thinking and behavior, but its progression is slow, spanning nearly two decades before the symptoms appear. Thus, it is imperative to understand the physiology at the pre-clinical stage. It is estimated that genetic factors contribute nearly 50% to AD. To better understand how genes contribute to the risk of AD by altering cellular milieu, we have examined the metabolome of high risk individuals, the APOE4 carriers. The metabolome represents the products that were generated from the genome and proteome. These biochemical products represent influences of both genetic and environmental factors. In this article, I prepared simulated data to reproduce and demonstrate a rough analysis pipeline due to security concerns.

### Goal

The aim of this simulation study is to identify a set of metabolites that will enable to differentiate bio-markers that are associated with AD vs. non-AD.

## Data Preparation

### Package Loading and Option Settings

```{r, message=FALSE,warning=FALSE}
#| code-fold: true

library(tidyverse)
library(tidymodels)
library(glmnet)
library(MASS)
#library(mixOmics)
set.seed(20221213) 
knitr::opts_chunk$set(message=FALSE,warning=FALSE)
```

### Data Simulation

```{r, echo=FALSE, eval=FALSE}
#| code-fold: true

# the number of samples
sample_size <- 1000
# the number of predictors
predictor_size <- 10000
group_size <- 10
# the number of predictors truly associated with a response variable
significant_predictors <- floor(predictor_size*sample((50:200)/1000,1)) 

## set the predictors associated with an outcome
### the number of predictors positively associated with an outcome
### the number of predictors negatively associated with an outcome
positively_associated_predictors<-floor(significant_predictors*0.4) 
negatively_associated_predictors<-significant_predictors-positively_associated_predictors 

## set correlated predictors within each group
### randomly sampling proportions of 10 correlated predictor groups 
### to become their sum equal to 1
proportion_list<-sample(seq(1,1+2*(100-group_size)/group_size,
                            by=2*(100-group_size)/(group_size*(group_size-1)))/100,
                        group_size,replace=FALSE)%>%round(3) 
names(proportion_list)<-paste0("group",1:length(proportion_list))
### initialize a matrix with a size as sample_size by predictor_size
predictor_matrix <- matrix(0, ncol = predictor_size, nrow = sample_size)
### initialize a data frame and assign meta information used to generate simulated data
meta_data<-
    data.frame(group_name=c(names(proportion_list)),
               proportion=proportion_list)%>%
    mutate(group_n=(predictor_size*proportion_list)%>%round(0), # the within-group number of predictors
           first_index=c(1,cumsum(group_n[-length(proportion_list)])+1), # the 1st index of predictors in each group
           last_index=cumsum(group_n), # the last index of predictors in each group
           group_correlation=sample((0:700)/1000,length(proportion_list),replace=TRUE), # correlation among the within-group predictors
           group_effect=sample((-2:2)/10,length(proportion_list),replace=TRUE)); # effect of each group on an outcome variable


data<-matrix(rnorm(sample_size*predictor_size,mean=0,sd=0.01), 
             nrow = sample_size, ncol = predictor_size)
covariance_matrix<-matrix(rnorm(predictor_size*predictor_size,0.15,0.05),
                          nrow=predictor_size, ncol=predictor_size)
beta_coefficients <- rnorm(predictor_size,0,0.05)

for (i in 1:nrow(meta_data)) {
    
    group_range <- meta_data[i, "first_index"]:meta_data[i, "last_index"]
    for (j in group_range){
        for(k in group_range){
        covariance_matrix[j, k] <- meta_data[i, "group_correlation"]
        }
    }
    #covariance_matrix[group_range, group_range]+meta_data[i, "group_correlation"]    
    diag(covariance_matrix) <- 1
    data[, group_range] <- 
        mvrnorm(n = sample_size, 
                mu = rep(0,meta_data[i,"group_n"]),
                Sigma = covariance_matrix[group_range, group_range])
    data=as.data.frame(data)
    beta_coefficients[meta_data[i, "first_index"]:meta_data[i, "last_index"]] <-
        beta_coefficients[meta_data[i, "first_index"]:meta_data[i, "last_index"]]+
        meta_data[i,"group_effect"]
    predictor_names<-paste0(meta_data[i,"group_name"],"_",1:meta_data[i,"group_n"])
    names(beta_coefficients)[meta_data[i, "first_index"]:meta_data[i, "last_index"]] <- predictor_names
    names(data)[meta_data[i, "first_index"]:meta_data[i, "last_index"]]<-predictor_names
        
}
score=as.matrix(data)%*%beta_coefficients # score of each sample
# logistic function to get a probability, intercept = 0, 
# to decrease prevalence, set p-0.2, negative probabilities into 0
probabilities <- ((1/(1+exp(-(0+score))))-rnorm(sample_size,m=0.2,sd=0.05))%>%
    ifelse(.>1,1,.)%>%abs()
response <- rbinom(sample_size, 1, probabilities) 

age_distribution=rchisq(sample_size,df=9)
sex_distribution=sample(c(0,1),sample_size,replace=TRUE,prob = c(0.45,0.55))
country_distribution=sample(c(0:3),sample_size,replace=TRUE,prob = c(0.3,0.2,0.2,0.3))
treatment_distribution=sample(c(0:2),sample_size,replace=TRUE,prob = c(0.7,0.2,0.1))
genotype_distribution=sample(c(0:5),sample_size,replace=TRUE,
                             prob = c(0.05,0.15,0.05,0.40,0.25,0.1))
phenotype_data<-
    data.frame(
        id=1:sample_size,
        outcome=response,
        probabilities=probabilities,
        age=ifelse(probabilities<0.15,age_distribution-4,
                   ifelse(probabilities<0.3,age_distribution-2,
                          ifelse(probabilities>0.5,age_distribution+3,
                                 ifelse(probabilities>0.7,age_distribution+6,age_distribution)))))%>%
    mutate(age=sapply(age,
                   function(x)(x-min(age))/(max(age)-min(age))*(105-65)+65)%>%round(0),
           sex=sex_distribution,
           country=country_distribution,
           treatment=treatment_distribution,
           treatment=ifelse(probabilities>0.7,1,
                            ifelse(probabilities>0.8,2,treatment)),
           genotype=genotype_distribution,
           genotype=ifelse(probabilities<0.1,0,
                           ifelse(probabilities<0.15,1,
                                  ifelse(probabilities>0.7,3,
                                         ifelse(probabilities>0.8,4,
                                                ifelse(probabilities>0.9,5,genotype))))),
           age=ifelse(outcome==0&genotype==0,age+10,
                      ifelse(outcome==0&genotype==1,age+5,
                             ifelse(genotype==4,age-3,
                                    ifelse(genotype==5,age-2,age)))),
           genotype=ifelse(outcome==1&genotype==3&age>83&age<92,4,genotype),
           genotype=ifelse(outcome==1&genotype==4&age>87,5,genotype))


all_data=inner_join(phenotype_data,data%>%mutate(id=1:n()),by="id")

#save(all_data, file="llfs_simulated_data.rda")
#write_rds(all_data,"llfs_simulated_data.rds")
```

### Load Data

```{r}
#| code-fold: true


#all_data=read_csv("C:/Users/kmkim/Desktop/my_project/website/docs/projects/data/llfs_simulated_data.rda",
#                  progress = show_progress(),
#                  show_col_types = FALSE)%>%

 all_data=read_rds("C:/Users/kmkim/Desktop/my_project/website/docs/projects/data/llfs_simulated_data.rds")%>%
     dplyr::select(-1,-probabilities)
 all_data=all_data%>%
     mutate(outcome=factor(outcome,levels=c(0,1)),
            sex=factor(sex,levels=c(0,1)),
            country=factor(country,levels=c(0,1)),
            treatment=factor(treatment,levels=c(0,1)),
            genotype=factor(genotype,levels=c(3,0,1,2,4,5))
            )
 
 dim(all_data)

```

## Data Description

This data include `r dim(mtcars)[1]` rows and 

    `r dim(mtcars)[1]`
this inline code works but it seems to rmd files look more organized and tidier.



## Architecture of Analysis Pipeline

## Methods

```{r, echo=FALSE,message=FALSE,warning=FALSE}
n <- 1000    # sample size
p <- 10000     # the number of predictors
significant_p <- p*0.25  # the number of predictors associated with a response variable

x <- matrix(rnorm(n*p), nrow=n, ncol=p)
y <- apply(x[,1:significant_p], 1, sum) + rnorm(n)

# Split data into train (2/3) and test (1/3) sets
train_rows <- sample(1:n, .66*n)
x.train <- x[train_rows, ]
x.test <- x[-train_rows, ]

y.train <- y[train_rows]
y.test <- y[-train_rows]

list.of.fits <- list()
for (i in 0:10) {
  fit.name <- paste0("alpha", i/10)
  
  list.of.fits[[fit.name]] <-
    cv.glmnet(x.train, y.train, type.measure="mse", alpha=i/10, 
      family="gaussian")
}

results <- data.frame()
for (i in 0:10) {
  fit.name <- paste0("alpha", i/10)
  
  predicted <- 
    predict(list.of.fits[[fit.name]], 
      s=list.of.fits[[fit.name]]$lambda.1se, newx=x.test)
  
  mse <- mean((y.test - predicted)^2)
  
  temp <- data.frame(alpha=i/10, mse=mse, fit.name=fit.name)
  results <- rbind(results, temp)
}

results
```

## Results

## Conclusion

## Bibliography


</div>