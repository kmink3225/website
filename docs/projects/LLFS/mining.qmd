---
title: "Data Mining"
subtitle: "Unsupervised Learning"
description: "Data mining was performed to observe patterns of data in macroscopic observations or in the level of large data."
author: Kwangmin Kim
date: 2023-02-18
execute:
  warning: false
  message: false
  freeze: true
format: 
  html:
    toc: true
    number-sections: true
    page-layout: full
    code-fold: true
---



<ul class="nav nav-pills" id="language-tab" role="tablist">
  <li class="nav-item" role="presentation">
    <button class="nav-link active" id="Korean-tab" data-bs-toggle="tab" data-bs-target="#Korean" type="button" role="tab" aria-controls="Korean" aria-selected="true">Korean</button>
  </li>
  <li class="nav-item" role="presentation">
    <button class="nav-link" id="English-tab" data-bs-toggle="tab" data-bs-target="#English" type="button" role="tab" aria-controls="knitr" aria-selected="false">English</button>
  </li>

<div class="tab-content" id="language-tabcontent">

<div class="tab-pane fade  show active" id="Korean" role="tabpanel" aria-labelledby="Korean-tab">

::: {#Korean .tab-pane .fade .show .active role="tabpanel" aria-labelledby="Korean-tab"}


```{r}
#| echo: false

# clear objects
rm(list=ls())

# setting datapath
if(grepl('kkm',getwd())){
    datapath="C:/Users/kkm/Desktop/projects/website/docs/"
}else{
    datapath="C:/Users/kmkim/Desktop/projects/website/docs/"
}

# load libraries
if(!require(janitor)) install.packages("janitor") 
if(!require(tidyverse)) install.packages("tidyverse") 
if(!require(tidymodels)) install.packages("tidymodels") 
if(!require(glmnet)) install.packages("glmnet") 
if(!require(MASS)) install.packages("MASS") 
if(!require(ggpubr)) install.packages("ggpubr") 
if(!require(car)) install.packages("car") 
if(!require(mixOmics)) install.packages("mixOmics") 
#if(!require(reticulate)) install.packages("reticulate") 
library(janitor)
library(tidyverse)
library(tidymodels)
library(glmnet)
library(MASS)
library(ggpubr) 
library(car) 
library(mixOmics)
#library(reticulate)

# set a seed number
set.seed(20230223) 

# load functions
source(paste0(datapath,"functions/R/functions.r"))

knitr::opts_chunk$set(message=FALSE,warning=FALSE)

# load simulation data
simulated_data<-read_rds(paste0(datapath,"data/llfs_simulated_data.rds"))
significant_metabolites<-read_rds(paste0(datapath,"data/llfs_fake_significant_metabolites.rds"))
# simple data pre-processing
all_data<-
    simulated_data%>%
    mutate(
      outcome=factor(outcome,levels=c("negative","positive")),
      sex=ifelse(sex==0,"man","woman"),
      sex=factor(sex,levels=c("man","woman")),
      genotype=factor(genotype,levels=c("e3","e2","e4"))
      )

# rename metabolite variables
predictor_size=1000
names(all_data)[6:ncol(all_data)]<-paste0("meta",1:predictor_size)


```

## Data Mining

### PCA (Principal Component Analysis)

* PCA using mixOmics
```{r}
#| eval: false
#| echo: false

X<-all_data[,-c(1:5)]
X<-all_data[,-c(1:5)]%>%dplyr::select(all_of(significant_metabolites))
result_pca<-mixOmics::pca(X)
names(all_data)%>%head
plotIndiv(result_pca,group=all_data[,'outcome'])
plotIndiv(result_pca,group=all_data[,'outcome'])  # plot the samples
plotVar(result_pca)    # plot the variables

```

* Basic Coding
```{r}
metabolite_data <- all_data[,-c(1:5)]
outcome_data <- all_data[,2]

# normalize the metaoblites
normalized_metabolite_data <- 
  as.data.frame(lapply(metabolite_data, function(x)scale_function(vector=x,method="min-max")))

# extract the latent variables (PCs: Principal Components)
pc_metabolites <- 
  prcomp(normalized_metabolite_data)%>%
  janitor::clean_names()

loadings_metabolites <- 
  as.data.frame(pc_metabolites$rotation)%>%
  janitor::clean_names()
transformed_metabolites <- 
  as.data.frame(pc_metabolites$x)%>%
  janitor::clean_names()


outcome_transformed_metabolites <- 
  transformed_metabolites%>%
  mutate(outcome=outcome_data)

ggplot(data=outcome_transformed_metabolites, aes(x=pc1, y=pc2)) +
  geom_point(alpha=.3) +
  stat_ellipse(type='norm', level=.99) +
  geom_abline(intercept = 0, slope = loadings_metabolites[2,1]/loadings_metabolites[1,1]) +
  geom_abline(intercept = 0, slope = loadings_metabolites[2,2]/loadings_metabolites[1,2]) +
  labs(title = '2D Scatter Plot of the First 2 PCs Grouped by AD status')

pr_components_df = data.frame(pr_components)
pr_components_df = cbind(pr_components_df,digits_data$target)
names(pr_components_df)[K_prcomps+1] = "target"

out <- split( pr_components_df , f = pr_components_df$target )
zero_df = out$`0`;one_df = out$`1`;two_df = out$`2`; three_df = out$`3`; four_df = out$`4`
five_df = out$`5`;six_df = out$`6`;seven_df = out$`7`;eight_df = out$`8`;nine_df = out$`9`



# Plotting 2-dimensional PCA
ggplot(pr_components_df, aes(x = PC1, y = PC2, color = factor(target,labels = c("zero","one","two",
        "three","four","five","six","seven","eight","nine")))) + 
        geom_point()+ggtitle("2-D PCA on Digits Data") +
        labs(color = "Digtis")



# 3- Dimensional PCA
# Plotting 3-dimensional PCA
K_prcomps = 3

pr_components = pr_components_all[,1:K_prcomps]
pr_components_df = data.frame(pr_components)
pr_components_df = cbind(pr_components_df,digits_data$target)
names(pr_components_df)[K_prcomps+1] = "target"

pr_components_df$target = as.factor(pr_components_df$target)

out <- split( pr_components_df , f = pr_components_df$target )
zero_df = out$`0`;one_df = out$`1`;two_df = out$`2`; three_df = out$`3`; four_df = out$`4`
five_df = out$`5`;six_df = out$`6`;seven_df = out$`7`;eight_df = out$`8`;nine_df = out$`9`

library(scatterplot3d)

colors <- c("darkred", "darkseagreen4", "deeppink4", "greenyellow", "orange"
            , "navyblue", "red", "tan3", "steelblue1", "slateblue")
colors <- colors[as.numeric(pr_components_df$target)]
s3d = scatterplot3d(pr_components_df[,1:3], pch = 16, color=colors,
              xlab = "PC1",ylab = "PC2",zlab = "PC3",col.grid="lightblue",main = "3-D PCA on Digits Data")
legend(s3d$xyz.convert(3.1, 0.1, -3.5), pch = 16, yjust=0,
       legend = levels(pr_components_df$target),col =colors,cex = 1.1,xjust = 0)
       
# Chosing number of Principal Components
pr_var =pr_out$sdev ^2
pr_totvar = pr_var/sum(pr_var)
plot(cumsum(pr_totvar), xlab="Principal Component", ylab ="Cumilative Prop. of Var.",
     ylim=c(0,1),type="b",main = "PCAs vs. Cum prop of Var Explained")

```

### K-means Clustering

```{r}

# K means
km_fit = kmeans(all_data[,-c(1:5)],centers = 2,iter.max = 300 )

# "K-Means Clustering- Confusion matrix")
# table(all_data[,1],km_fit$cluster)

mat_avgss = matrix(nrow = 20, ncol = 2)

# Average within the cluster sum of square
print(paste("Avg. Within sum of squares"))
for (i in (1:20)){
  km_fit = kmeans(all_data[,-c(1:6)],centers = i,iter.max = 300 )
  mean_km = mean(km_fit$withinss)
  print(paste("K-Value",i,",Avg.within sum of squares",round(mean_km,2)))
  mat_avgss[i,1] = i
  mat_avgss[i,2] = mean_km
}

plot(mat_avgss[,1],mat_avgss[,2],type = 'o',xlab = "K_Value",ylab = "Avg. within sum of square")
title("Avg. within sum of squares vs. K-value")


mat_varexp = matrix(nrow = 20, ncol = 2)
# Percentage of Variance explained
print(paste("Percent. variance explained"))
for (i in (1:20)){
  km_fit = kmeans(all_data[,-c(1:6)],centers = i,iter.max = 300 )
  var_exp = km_fit$betweenss/km_fit$totss
  print(paste("K-Value",i,",Percent var explained",round(var_exp,4)))
  mat_varexp[i,1]=i
  mat_varexp[i,2]=var_exp
}

plot(mat_varexp[,1],mat_varexp[,2],type = 'o',xlab = "K_Value",ylab = "Percent Var explained")
title("Avg. within sum of squares vs. K-value")
```



```{r}
#| eval: false
#| echo: false

#SVD 
library(svd)

digits_data = read.csv("digitsdata.csv")

remove_cols = c("target")
x_data = digits_data[,!(names(digits_data) %in% remove_cols)]
y_data = digits_data[,c("target")]



sv2 <- svd(x_data,nu=15)

sv_check = sv2$d

# Computing the square of the singular values, which can be thought of as the vector of matrix energy
# in order to pick top singular values which preserve at least 80% of variance explained
energy <- sv2$d ^ 2
tot_varexp = data.frame(cumsum(energy) / sum(energy))

names(tot_varexp) = "cum_var_explained"
tot_varexp$K_value = 1:nrow(tot_varexp)

plot(tot_varexp[,2],tot_varexp[,1],type = 'o',xlab = "K_Value",ylab = "Prop. of Var Explained")
title("SVD - Prop. of Var explained with K-value")


```

```{r}
#| echo: false
#| eval: false

for (i in 1:p) {
 form = paste("lm(", paste0(var[i], collapse="+"), "~ . , data=as.data.frame(data) ) ")
 fit = eval(parse(text=form)); fit
 lm_result[i] = list(summary(fit))
}

```


:::
</div>

<div class="tab-pane fade" id="English" role="tabpanel" aria-labelledby="English-tab">

::: {#English .tab-pane .fade role="tabpanel" aria-labelledby="English-tab"}

:::


</div>

