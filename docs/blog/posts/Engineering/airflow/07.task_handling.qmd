---
title: "Template Variabler"
subtitle: DAG Creation, Bash Operator, Task Performance Subject, 
description: |
  template
categories:
  - Engineering
author: Kwangmin Kim
date: 05/01/2023
format: 
  html:
    page-layout: full
    code-fold: true
    toc: true
    number-sections: true
comments: 
  utterances: 
    repo: ./docs/comments
draft: False
---

<ul class="nav nav-pills" id="language-tab" role="tablist">
  <li class="nav-item" role="presentation">
    <button class="nav-link active" id="Korean-tab" data-bs-toggle="tab" data-bs-target="#Korean" type="button" role="tab" aria-controls="Korean" aria-selected="true">Korean</button>
  </li>
  <li class="nav-item" role="presentation">
    <button class="nav-link" id="English-tab" data-bs-toggle="tab" data-bs-target="#English" type="button" role="tab" aria-controls="knitr" aria-selected="false">English</button>
  </li>

<div class="tab-content" id="language-tabcontent">

<div class="tab-pane fade  show active" id="Korean" role="tabpanel" aria-labelledby="Korean-tab">

::: {#Korean .tab-pane .fade .show .active role="tabpanel" aria-labelledby="Korean-tab"}

# Task 분기 처리하기 With BranchPythonOperator

## Task 분기 처리 유형

* Task 분기처리가 필요한 이유
    * task1의 결과에 따라 task2-x 중 하나만 수행하도록 구성해야 할 때
    * eg) Task1 의 결과로 ‘Good’,’Bad’,’Pending’ 이라는 결과 3 개 중 하나가 나오고 
    그에 따라 ask2 1 ~ task2 3 중 하나가 실행되도록 해야 할 경우

## Task 분기처리 방법

* Task 분기처리 방법
    * BranchPythonOperator
    * task.branch 데커레이터 이용
    * BaseBranchOperator 상속하여 직접 개발

### BranchPythonOperator

```markdown

def select_random():
import random

item_lst= ['A','B','C']
selected_item = random.choice(item_lst)
if selected_item == 'A';
    return 'task_a'
elif selected_item in ['B','C] 
    return ['task_b','task_c']

python_branch_task = BranchPythonOperator(
    task_id ='python_branch_task',
    python_callable=select_random
)

python_branch_task >> [task_a , task_b , task_c]

```


```{dot}

digraph G {
  compound=true;
  rankdir=LR;
  subgraph cluster0 {
    rankdir=TB;
    task1 [shape=box];
    task2_1 [shape=box];
    task2_2 [shape=box];
    task2_3 [shape=box];
    
    label= "Task Flow";
  }

  task1 -> task2_1;
  task1 -> task2_2;
  task1 -> task2_3;
  
}
```

# Task 분기처리하기 with task.branch

## Task.branch 이해

```markdown
from airflow.operators.python import
BranchPythonOperator
def select_random(): 
    import random
    item_lst = ['A','B','C']
    selected_item = random.choice(item_lst)
    if selected_item == 'A':
        return 'task_a'
    elif selected_item in ['B','C']
        return ['task_b','task_c']

python_branch_task = BranchPythonOperator(
    task_id= 'branching',
    python_callable = select_random
)
python_branch_task >> [task_a , task_b , task_c]

```

```markdown
from airflow.operators.python import

@task.branch(task_id='python_branch_task')
def select_random(): 
    import random
    item_lst = ['A','B','C']
    selected_item = random.choice(item_lst)
    if selected_item == 'A':
        return 'task_a'
    elif selected_item in ['B','C']
        return ['task_b','task_c']

select_random() >> [task_a , task_b , task_c]

```

# Task 분기처리하기 With BaseBranchOperator

## BaseBranchOperator 이해 요약

```markdown
from airflow.operators.branch import BaseBranchOperator
with DAG(...
) as dag:
    class CustomBranchOperator(BaseBranchOperator):
        def choose_branch(self,context):
            import random
            
            item_lst = ['A', 'B','C]
            selected_item = random.choice(item_lst)
            if selected_item == 'A':
                return 'task_a'
            elif selected_item in ['B','C']:
                return ['task_b','task_c']

custom_branch_operator = CustomBranchOperator(task_id ='python_branch_task')
custom_branch_operator >> [task_a , task_b , task_c]
```

* 클래스 상속 BaseBranchOperator 상속시 choose_branch 함수를 구현해 줘야 함

## Summary

* Task 분기처리 방법
    1. BranchPythonOperator
    1. task.branch 데커레이터 이용
    1. BaseBranchOperator 상속 , choose_branch 를 재정의해야 함
* 공통적으로 리턴 값으로 후행 Task 의 id 를 str 또는 list 로 리턴해야 함
* 3가지 분기처리 방법은 방법만 다를 뿐 결과는 동일함
* 3 보다는 1 또는 2를 주로 사용함

# Trigger Rule

## Trigger Rule 종류

```{dot}
digraph G {
  compound=true;
  rankdir=LR;
  subgraph cluster0 {
    rankdir=TB;
    task1 [shape=box];
    task2 [shape=box];
    task3 [shape=box];
    task4 [shape=box];
    
    label= "Task Flow";
  }

  task1 -> task4;
  task2 -> task4;
  task3 -> task4; 
}
```

* 상위 Task 들의 상태에 따라 수행여부 결정하고 싶은데 (기본 값 : 상위 Task 모두 성공시에만 수행)

| Default                       | Left      |
|:------------------------------|:----------|
| all_success (default)         | 상위 task 가 모두 성공하면 실행  |
| all_failed                    | 상위 task 가 모두 실패하면 실행  |
| all_done                      | 상위 task 가 모두 수행되면 실행 (실패도 수행된것에 포함)  |
| all_skipped                   | 상위 task 가 모두 Skipped 상태면 실행  |
| one_failed                    | 상위 task 중 하나 이상 실패하면 실행 (모든 상위 Task 완료를 기다리지 않음) |
| one_success                   | 상위 task 중 하나 이상 성공하면 실행 (모든 상위 Task 완료를 기다리지 않음) |
| one_done                      | 상위 task 중 하나 이상 성공 또는 실패 하면 실행|
| none_failed                   | 상위 task 중 실패가 없는 경우 실행 (성공 또는 Skipped 상태) |
| none_failed_min_one_success   | 상위 task 중 실패가 없고 성공한 Task가 적어도 1개 이상이면 실행 |
| none_skipped                  | Skip된 상위 Task가 없으면 실행 (상위 Task가 성공, 실패하여도 무방)   |
| always                        | 언제나 실행 |


## 2. Trigger Rule 실습) all_done

```markdown

bash_upstream_1 = BashOperator(
    task_id = 'bash_upstream_1',
    bash_command = 'echo upstream1'
)

@task(task_id =='python_upstream_1')
def python_upstream_1():
    AirflowException('downstream_1 Exception!')

@task(task_id =='python_upstream_2')
def python_upstream_2():
    print('정상 처리')

@task(task_id ='python_downstream_1', trigger_rule =='all_done')
def python_downstream_1():
    print('정상 처리')

[bash_upstream_1 , python_upstream_1(), python_upstream_2()] >> python_downstream_1()

```

## 2. Trigger Rule 실습) none_skipped

```markdown
@task.branch(task_id ='branching')
def random_branch():
    import random
    item_lst = [' A', ' B', 'C']
    selected_item = random.choice(item_lst)
    if selected_item == 'A':
        return 'task_a'
    elif selected_item == 'B':
        return 'task_b'
    elif selected_item == 'C':
        return 'task_c'

task_a = BashOperator(
    task_id ='task_a',
    bash_command = 'echo upstream1'
    )

@task(task_id ='task_b')
def task_b():
    print('정상 처리')

@task(task_id =='task_c')
def task_c():
    print('정상 처리')

@task(task_id =='task_d', trigger_rule ='none_skipped')
def task_d():
    print('정상 처리')

random_branch() >> [task_a , task_b(), task_c()] >> task_d()

```

# Task Group

## Task Group 개념

* Task들의 모음
* [UI Graph탭에서 Task 들을 Group 화하여 보여줌](https://airflow.apache.org/docs/apache-airflow/stable/core-concepts/dags.html#taskgroups)
* Task Group 안에 Task Group 을 중첩하여 구성 가능

## Task Group 실습 (task_group 데커레이터 이용)

```markdown
from airflow.decorators import task_group
with DAG(...
) as dag:
    @task_group(group_id ='first_group')
    def group_1():
    ''' task_group 데커레이터를 이용한 첫 번째 그룹입니다. '''

    @task(task_id ='inner_function1')
    def inner_func1(**kwargs):
        print('첫 번째 TaskGroup 내 첫 번째 task 입니다')

    inner_function2 = PythonOperator(
        task_id ='inner_function2',
        python_callable = inner_func,
        op_kwargs={'msg':'첫 번째 TaskGroup 내 두 번쨰 task 입니다.'}
    )
    inner_func1() >> inner_function2
```

## Task Group 실습 (클래스 이용)

```markdown
from airflow.utils.task_group import TaskGroup
    with TaskGroup(group_id ='second_group', tooltip='두 번째 그룹입니다.') as group_2:
        @task(task_id ='inner_function1')
        def inner_func1 (**kwargs):
            print('두 번째 TaskGroup 내 첫 번째 task 입니다.')

        inner_function2 = PythonOperator(
            task_id = 'inner_function2',
            python_collable = inner_func,
            op_kwargs = {'msg': '두 번째 TaskGroup 내 두 번째 task 입니다'}
        )
inner_func1() >> inner_function2
```

## 요약

* Task Group 작성 방법은 2 가지가 존재함
    (데커레이터 & 클래스)
* Task Group 안에 Task Group 중첩하여 정의 가능
* Task Group 간에도 Flow 정의 가능
* Group이 다르면 task_id 가 같아도 무방
* Tooltip 파라미터를 이용해 UI 화면에서 Task group 에 대한 설명 제공 가능
    (데커레이터 활용시 docstring 으로도 가능)

# Edge label

## Edge Label 개념

* Task 연결에 대한 설명 (Comment)

## Edge Label 만들기

```{dot}
digraph G {
  compound=true;
  rankdir=LR;
  subgraph cluster0 {
    rankdir=TB;
    ingest [shape=box];
    analyze [shape=box];
    check_integrity [shape=box];
    describe_integrity [shape=box];
    email_error [shape=box];
    report [shape=box];
    save [shape=box];
    label= "Task Flow";
  }

  ingest -> analyze ;
  analyze -> check_integrity ;
  check_integrity -> describe_integrity[label="Errors Found"];
  describe_integrity -> email_error;
  email_error -> report;
  check_integrity -> save[label="No Errors"];
  save -> report;
  
  
}
```

## Edge Label 실습 1

```markdown

from airflow.utils.edgemodifier import Label
empty_1 = EmptyOperator(
    task_id ='empty_1'
)

empty_2 = EmptyOperator(
    task_id='empty_2'
)
empty_1 >> Label ('1 과 2 사이') >> empty_2
```

## Edge Label 실습 2

```markdown

from airflow.utils.edgemodifier import Label
empty_2 = EmptyOperator(
    task_id = 'empty_2'
)

empty_3 = EmptyOperator(
    task_id ='empty_3'
)

empty_4 = EmptyOperator(
    task_id ='empty_4'
)

empty_5 = EmptyOperator(
    task_id ='empty_5'
)

empty_6 = EmptyOperator(
    task_id ='empty_6'
)

empty_2 >> Label('Start Branch') >> [empty_3, empty_4, empty_5 ] >> Label('End Branch') >> empty_6
```

:::

</div>

<div class="tab-pane fade" id="English" role="tabpanel" aria-labelledby="English-tab">

::: {#English .tab-pane .fade role="tabpanel" aria-labelledby="English-tab"}

:::


</div>


# Go to Blog Content List

[Blog Content List](../../content_list.qmd)