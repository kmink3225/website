{
  "hash": "e07ef5c0ed547356f3b71e2d2aea201a",
  "result": {
    "markdown": "---\ntitle: \"Data Preparation\"\nsubtitle: \"Simulation\"\ndescription: \"I could not share real data due to security issues, so I made simulation data to show a rough analysis methodology used for this projects. Therefore, this simulation data simply reflects generally known facts and the ones published on wikipedia, but does not reflect the distribution of sample data that was actually used, so the information derived from this data may differ from generally known biological or biomedical facts. \\n 보안 문제로 real data를 공유하진 못하여 대략적인 분석 방법론을 보여주기위해 시뮬래이션 데이터를 만들었습니다. 따라서, 이 시뮬래이션 데이터는 일반적으로 알려진 사실과 wikipedia에 공개된 사실을 간단히 반영했지만 실제로 사용됐던 sample data의 분포를 반영하지 않았기 때문에 이 데이터에서 나온 정보는 일반적으로 알려진 생물학적 그리고 의학적 사실과 다를 수 있습니다. \"\nauthor: Kwangmin Kim\ndate: 2022-12-20\n#image: images/high_dimensions.jpg\nformat:\n  html:\n    toc: true\n    number-sections: true\n    code-fold: true\n    code-summary: \"Show the code\"\n    page-layout: full\nexecute:\n  warning: false\n  message: false\n  freeze: true\n---\n\n\n## Simulation Flowchart\n\n\n```{mermaid}\n%%| fig-width: 7.5\n%%| fig-height: 9\nflowchart TB\n    subgraph Simulation\n        direction TB\n        subgraph Assign_Setting_Values\n            direction LR\n            Assign_Sample_Size---\n            Assign_Dimension_Size---\n            Assign_Covariance_Correlation---\n            Assign_Several_Proportions---\n            Assign_Noise_Intensity\n        end\n        subgraph Generate_Metabolite_Variables\n            direction LR\n            Generate_Covariance_Matrix---\n            Apply_Noise_to_Covariance---\n            Generate_Weights_Matrix---\n            Use_MVN_Distribution---\n            Generate_Metabolite_Data\n        end\n        subgraph Generate_Outcome_Variable\n            direction LR\n            Calculate_Score_Matrix---\n            Use_Logit_Link---\n            Calculate_Outcome_Probabilities---\n            Use_Binomial_Distribution1---\n            Generate_Binary_Outcome_Data\n        end\n        subgraph Generate_Sex_Variable\n            direction LR\n            Use_Binomial_Distribution2---\n            Generate_Sex_Data\n        end\n        subgraph Generate_Age_Variable\n            direction LR\n            Search_the_Strongest_Metabolite---\n            Rescale_It_to_Age---\n            Generate_Age_Data\n        end\n        subgraph Generate_Genotype_Variable\n            direction LR       \n            Calculate_Marginal_Proportions---\n            Calcualte_Joint_Proportions---\n            Generate_Genotype_data\n        end\n        subgraph Merge_All_Data\n            direction LR\n            Outcome_Variable---\n            Sex_Variable---\n            Age_Variable---\n            Genotype_Variable---\n            Metabolite_Data\n        end\n        Assign_Setting_Values-->Generate_Metabolite_Variables-->Generate_Outcome_Variable-->\n        Generate_Sex_Variable-->Generate_Age_Variable-->Generate_Genotype_Variable-->\n        Merge_All_Data\n    end\n    subgraph Data_Analytics\n        direction LR\n        exploratory_data_analysis---\n        statistical_analysis---\n        machine_learning\n    end\n    subgraph Conclusion\n        direction LR\n    end\n    Simulation-->Data_Analytics-->Conclusion\n```\n\n\n* MVN: Multivariate Normal Distirubtion\n\n<ul class=\"nav nav-pills\" id=\"language-tab\" role=\"tablist\">\n\n<li class=\"nav-item\" role=\"presentation\">\n\n<button class=\"nav-link active\" id=\"Korean-tab\" data-bs-toggle=\"tab\" data-bs-target=\"#Korean\" type=\"button\" role=\"tab\" aria-controls=\"Korean\" aria-selected=\"true\">\n\nKorean\n\n</button>\n\n</li>\n\n<li class=\"nav-item\" role=\"presentation\">\n\n<button class=\"nav-link\" id=\"English-tab\" data-bs-toggle=\"tab\" data-bs-target=\"#English\" type=\"button\" role=\"tab\" aria-controls=\"knitr\" aria-selected=\"false\">\n\nEnglish\n\n</button>\n\n</li>\n\n<div class=\"tab-content\" id=\"language-tabcontent\">\n\n::: {#Korean .tab-pane .fade .show .active role=\"tabpanel\" aria-labelledby=\"Korean-tab\"}\n\n대략적인 분석 방법론을 간단히 보여주기 위해 Simulation을 수행했다. 이해를 돕기위해 Simulation 순서도를 간략히 설명하자면 크게 7 단계로 Simulation을 수행했다.\n\n#### 설정값 생성\n\n**Data Set Size Setting**  \n\nSimulation에 필요한 몇 가지 설정값들을 Global Variables로 설정하여 후차적으로 작성된 스크립트에서 호출이 자유롭도록 작성했다. 변수들은 아래의 Simulation section에 있는 **Global Variables** (see @sec-global_variables) 에서 확인 가능하다.\n\n**Categorial Data Setting**\n\n먼저, 고차원 데이터의 차원을 설정하기 위해 Sample Size와 변수의 수를 설정한 후 Categorical predictors를 만들기 위해 잘 알려진 분포, 내가 정한 분포, 혹은 임의로 발생하게 만든 분포를 설정하였다. (see @sec-global_variables, @sec-functions, and @sec-simulation)\n\n**Sex Variable Setting**\n\nSex 변수는 $X \\sim \\text{Bernoulli}(0.5)$ 을 통해 data를 생성했다. (see @sec-simulation)\n\n**Genotype Variable Setting**\n\nGenotype 변수의 data는 아직도 어떻게 통계적으로 생성해야하는지 감을 못잡은 상태이기 때문에 더 연구가 필요하다. 하지만, 질병에 대한 유전적 영향도는 반영해야하기 때문에 outcome variable과 이미 잘 알려진 genotype의 분포를 반영하려고 노력했다. 두 변수에 연관성을 갖게하기 위해 각 변수의 proportion을 marginal distirubtion으로 설정하여 두 변수의 joint proportion을 계산하여 Genotype data를 생성했다. (see @sec-functions and @sec-simulation)\n\n**Metabolite Data Setting**\n\n고차원의 metabolite data를 만드는 설정으로, 고차원이면서 그룹내 서로 상관 관계가 있는 변수들을 생성하기 위해 난수에 의해 발생되는 임의의 Covariance를 생성하여 MVN (Multivariate Normal Distribution)에 반영되게 했고 각 그룹의 반응 변수로의 영향(또는 가중치)도 또한 난수로 임의적으로 발생되게 설정했다. 이때, 난수에 의해 임의적으로 발생하는 수치는 내가 임의적으로 범위를 한정했다. 재현성을 위해 seed number를 고정했다. (see @sec-simulation)\n\n**Outcome Variable Setting**\n\nMVN에 의해 만들어진 Data와 미리 만들어 놓은 가중치 Matrix의 곱을 통해 Score Matrix를 만들고 Logit Link를 이용하여 각 Sample의 확률값을 만들었다. 각 Sample의 확률값을 기반으로 $X \\sim \\text{Bernoulli}(p)$, (여기서 $p$는 각 sample이 갖는 확률값을 뜻한다), 을 통해 disease status의 정보를 담은 binary outcome variable를 만들었다. (see @sec-simulation)\n\n**Age Variable Setting**\n\nAge 변수는 생물학적, 의학적으로 치매와 연관성이 높은 요인으로 Outcome 변수로 가장 설명이 잘되는 metabolite를 탐색해 선별하여 Age 형태로 변환을 했다. 제일 어린 사람을 65세 그리고 제일 연장자를 105세로 설정하여 min max normalization을 적용했다. (see (see @sec-functions and @sec-simulation)\n\n**Merge All Data**\n\nSimulation을 통해 만들어진 각 변수들을 index를 만들어 병합시켜 data frame의 형태로 만들었다. (see @sec-simulation)\n\n**Analytics & Conclusion**\n\n분석 부분은 이 data preparation section에서는 자세히 기술하지 않고 EDA, Statistical Approach 및 ML Approach Section에서 자세히 다룰예정이다. 간략히 말하면, outcome 변수와 통계적으로 유의한 관계를 갖는 metabolite를 선별하고 그 결과가 machine learning을 이용하여 얻은 결과와 얼마나 같은지 비교 분석을 하여 Outcome variable에 가장 연관성이 있는 변수들을 규명하는 방법을 기술할 예정이다.\n\n\n::: {.cell}\n\n:::\n\n\n\n## Simulation\n\n### Package Loading and Option Settings\n\n::: {.cell}\n\n```{.r .cell-code}\nif(!require(janitor)) install.packages(\"janitor\") \nif(!require(tidyverse)) install.packages(\"tidyverse\") \nif(!require(tidymodels)) install.packages(\"tidymodels\") \nif(!require(glmnet)) install.packages(\"glmnet\") \nif(!require(MASS)) install.packages(\"MASS\") \nif(!require(ggpubr)) install.packages(\"ggpubr\") \nif(!require(car)) install.packages(\"car\") \nif(!require(mixOmics)) install.packages(\"mixOmics\") \n\nlibrary(janitor)\nlibrary(tidyverse)\nlibrary(tidymodels)\nlibrary(glmnet)\nlibrary(MASS)\nlibrary(ggpubr) \nlibrary(car) \nlibrary(mixOmics)\nset.seed(20230103) \nknitr::opts_chunk$set(message=FALSE,warning=FALSE)\n```\n:::\n\n\n### Global Variables {#sec-global_variables}\n\n::: {.cell}\n\n```{.r .cell-code}\n# the number of samples\nsample_size <- 500 #1000\n# the number of predictors\npredictor_size <- 1000 #5000\n# the number of groups\ngroup_size <- sample(6:10,1) # at least more than 6, the number of the genotypes\n# the number of predictors truly associated with a response variable\nsignificant_predictors <- floor(predictor_size*sample((50:100)/1000,1)) \n\n## set the predictors associated with an outcome\n### the number of predictors positively associated with an outcome\n### the number of predictors negatively associated with an outcome\npositively_associated_predictors<-floor(significant_predictors*0.4) \nnegatively_associated_predictors<-significant_predictors-positively_associated_predictors \n\n## set the proportion of the groups in which the predictors are correlated with one another\n### randomly sampling proportions to become their sum equal to 1\ngroup_proportion_list<-sample(seq(1,1+2*(100-group_size)/group_size,\n                            by=2*(100-group_size)/(group_size*(group_size-1)))/100,\n                        group_size,replace=FALSE)%>%round(3) \nnames(group_proportion_list)<-paste0(\"group\",1:length(group_proportion_list))\n### initialize a matrix with a size as sample_size by predictor_size\npredictor_matrix <- matrix(0, ncol = predictor_size, nrow = sample_size)\n### initialize a data frame and assign meta information used to generate simulated data\ngroup_meta_data<-\n    data.frame(\n        group_name=c(names(group_proportion_list)),\n        proportion=group_proportion_list)%>%\n        mutate(\n            # the number of predictors within each group \n            group_n=(predictor_size*group_proportion_list)%>%round(0),\n            # the 1st index of predictors in each group\n            first_index=c(1,cumsum(group_n[-length(group_proportion_list)])+1), \n            # the last index of predictors in each group\n            last_index=cumsum(group_n),\n            # within-group correlations among the within-group predictors \n            group_correlation=sample((0:700)/1000,length(group_proportion_list),replace=TRUE),\n            # effect of each group on an outcome variable \n            group_effect=sample((-40:30)/100,length(group_proportion_list),replace=TRUE)) \n### set a group effect as 0.7 into a group with the smallest group number \ngroup_meta_data[which.min(group_meta_data[,\"group_n\"]),\"group_effect\"]<-0.7\n\n### set a group effect as -0.5 into a group with the second smallest group number \ngroup_meta_data[group_meta_data[,\"group_n\"]==(sort(group_meta_data[,\"group_n\"])[2]),\"group_effect\"]<-(-0.5)\n\n# initialize a data matrix to assign simulated values\n## add some noise to data\ndata<-matrix(rnorm(sample_size*predictor_size,mean=0,sd=0.05), \n             nrow = sample_size, ncol = predictor_size)\n\n# initialize a covariance matrix to assign simulated values\ncovariance_matrix<-matrix(rnorm(predictor_size*predictor_size,mean=0,sd=0.05),\n                          nrow=predictor_size, ncol=predictor_size)\nbeta_coefficients <- rnorm(predictor_size,0,0.05)\n\nanswer_list<-list(\n    'sample size'=sample_size,\n    'predictor size'=predictor_size,\n    'group size'=group_size,\n    'significant predictors'=significant_predictors,\n    'positively associated predictors'=positively_associated_predictors,\n    'negatively associated predictors'=negatively_associated_predictors,\n    'group proportion list'=group_proportion_list,\n    'group meta data'=group_meta_data,\n    'data noise intensity'=c('distribution'='rnorm','mean'=0,'sd'=0.05),\n    'covariance noise intensity'=c('distribution'='rnorm','mean'=0,'sd'=0.05),\n    'effect noise intensity on response'=c('distribution'='rnorm','mean'=0,'sd'=0.05),\n    'link function between the response and predictors' = 'canonical logit link function',\n    'link function noise intensity' = c('distribution'='rnorm','mean'=0,'sd'=0.05),\n    'age_distirbution'='used data of a variable with the highest effect on outcome',\n    'sex_distribution'='rbinom(n=sample size,p=0.5)',\n    'genotype_distirbution'=c('e2' = '8.4%','e3' = '77.9%','e4' = '13.7%'))\n```\n:::\n\n\n### Functions {#sec-functions}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Function List\n\nscale_function=function(vector=x,min=NULL,max=NULL,method=\"customized\"){\n    if(method==\"min-max\"){\n        result=(vector-min(vector))(max(vector)-min(vector))\n    }else if(method==\"customized\"){\n        result=(max-min)*(vector-min(vector))/(max(vector)-min(vector))+min\n    }else{\n        result=(vector-mean(vector))/sd(vector)\n    }\n  return(result)\n}\n\nage_data_generator=function(in_data,in_response,fun=scale_function){\n    # this function generates a age (continuous) data \n    # that are statistically associated with a simulated variable as designed above.\n\n    ## conduct t test with the response and each variable generated by multivariate normal distributions.\n    ## search a variable with the largest difference in mean between the two groups or with the lowest p value\n    ## In this case, I will pick the former one. \n    ## (I don't care about the multiple testing problems for now)\n    temp_df=as.data.frame(matrix(ncol=5)) # initialize an empty data frame\n    for(i in 1:ncol(in_data)){\n        temp_df[i,]=c(\n            names(in_data)[i],\n            t.test(in_data[,i]~in_response)$estimate[1],\n            t.test(in_data[,i]~in_response)$estimate[2],\n            t.test(in_data[,i]~in_response)$estimate[2]-t.test(data[,i]~response)$estimate[1],\n            t.test(in_data[,i]~in_response)$p.value)\n    }\n    names(temp_df)<-c('metabolite','mean_neg','mean_pos','mean_diff','p.value')\n\n    ## search a variable with the largest difference in mean\n    strong_metabolite<-\n        temp_df%>%\n        mutate(\n            mean_neg=as.numeric(mean_neg),\n            mean_pos=as.numeric(mean_pos),\n            mean_diff=as.numeric(mean_diff),\n            p.value=as.numeric(p.value),\n            abs_mean_diff=abs(mean_diff))%>%\n        filter(abs_mean_diff==max(abs_mean_diff))%>%\n        dplyr::select(metabolite)%>%pull\n    \n    ## generate age data with min max normalization\n    age_data<-\n        data%>%\n        dplyr::select(strong_metabolite)%>%\n        scale_function(vector=.,min=65,max=105,method=\"customized\")%>%\n        rename(age=1)%>%round(0)\n    return(age_data)\n}\n\n\ngenotype_data_generator=function(in_response=response,fun=scale_function){\n    # this function generates a genotype (categorical) data \n    # that are jointly and statistically associated with a continuous data and a binary data \n    # (I am not so sure if I can generate data that are statistically associated with \n    # some fake metabolite data. But, I will give it a try).\n\n    ## Declare the marginal proportions \n    ## for binary (affected vs unaffected) and a genotype (categorical) data, respectively\n    binary_proportion<-as.numeric(table(in_response)/sample_size) #the simulated proportion for the disease vs non-disease cases\n    genotype_proportion<-c(0.084,0.779,0.137) # the known proportion of APOE genotypes from Wiki\n\n    ## Declare the joint proportion predictor matrix\n    joint_proportion<-matrix(\n        c(binary_proportion[1]*genotype_proportion, # for the unaffected cases\n        binary_proportion[2]*genotype_proportion),  # for the affected cases\n        ncol=2, byrow=FALSE)\n\n    # Generate the genotype (catogrical) data\n    genotype_data = numeric(sample_size) # initialize a vector \n    for (i in 1:sample_size) {\n        genotype_data[i] = sample(\n            c('e2','e3','e4'),\n             1, \n             prob=joint_proportion[,ifelse(grepl('neg',in_response[i]),1,2)])\n    }    \n    return(genotype_data)\n}\n```\n:::\n\n\n\n### Simulation {#sec-simulation}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# generate simulation data using multivariate normal distribution\nfor (i in 1:nrow(group_meta_data)) {\n    \n    group_range <- group_meta_data[i, \"first_index\"]:group_meta_data[i, \"last_index\"]\n    for (j in group_range){\n        for(k in group_range){\n        covariance_matrix[j, k] <- group_meta_data[i, \"group_correlation\"]\n        }\n    }\n    #covariance_matrix[group_range, group_range]+group_meta_data[i, \"group_correlation\"]    \n    diag(covariance_matrix) <- 1\n    data[, group_range] <- \n        mvrnorm(n = sample_size, \n                mu = rep(0,group_meta_data[i,\"group_n\"]),\n                Sigma = covariance_matrix[group_range, group_range])\n    data=as.data.frame(data)\n    beta_coefficients[group_meta_data[i, \"first_index\"]:group_meta_data[i, \"last_index\"]] <-\n        beta_coefficients[group_meta_data[i, \"first_index\"]:group_meta_data[i, \"last_index\"]]+\n        group_meta_data[i,\"group_effect\"]\n    predictor_names<-paste0(group_meta_data[i,\"group_name\"],\"_\",1:group_meta_data[i,\"group_n\"])\n    names(beta_coefficients)[group_meta_data[i, \"first_index\"]:group_meta_data[i, \"last_index\"]] <- predictor_names\n    names(data)[group_meta_data[i, \"first_index\"]:group_meta_data[i, \"last_index\"]]<-predictor_names\n        \n}\nscore=as.matrix(data)%*%beta_coefficients # score of each sample\n\n# logistic function to get a probability, intercept = 0, \n## set probabilities-0.2 to apply noise and negative probabilities into 0\nprobabilities <- \n    ((1/(1+exp(-(0+score))))-rnorm(sample_size,m=0.2,sd=0.05))%>%\n    ifelse(.>1,1,.)%>%\n    ifelse(.<0,0,.)\n\nresponse <-\n    ifelse(rbinom(sample_size, 1, probabilities)==0,'negative','positive')%>%\n    factor(.,levels=c('negative','positive'))\n\n# simulate sex data\nsex_data <- rbinom(sample_size,1,0.5)\n\n# simulate age data\nage_data <- age_data_generator(in_data=data,in_response=response)\n\n# simulate genotype data\ngenotype_data <- genotype_data_generator(in_response=response)\n\n# merge the univariables\nphenotype_data<-\n    data.frame(\n        id=1:sample_size,\n        outcome=response,\n        age=age_data,\n        sex=sex_data,\n        genotype=genotype_data)\n\nall_data=inner_join(\n    phenotype_data,\n    data%>%mutate(id=1:n()),\n    by=\"id\")\n\n#write_rds(all_data,\"./docs/data/llfs_simulated_data.rds\")\n```\n:::\n\n\n### Load Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load simulation data\nsimulated_data<-read_rds(datapath)\n\n# simple data pre-processing\nall_data<-\n    simulated_data%>%\n    mutate(\n      outcome=factor(outcome,levels=c(\"negative\",\"positive\")),\n      sex=ifelse(sex==0,\"man\",\"woman\"),\n      sex=factor(sex,levels=c(\"man\",\"woman\")),\n      genotype=factor(genotype,levels=c(\"e3\",\"e2\",\"e4\"))\n      )\n\n# rename metabolite variables\nnames(all_data)[6:ncol(all_data)]<-paste0(\"meta\",1:predictor_size)\n```\n:::\n\n\n\n## Data Description\n\nThis data include 500 samples and 1005 variables:\n\n* id: sample ID.\n* outcome: a disease status (positive, negative), positive is an affected status, negative is an unaffected status, and the reference group is positive.\n* age: age\n* sex: sex (man, woman) and the reference group is man.\n* genotype: APOE genotypes\n    * the apolipoprotein $\\epsilon$ (APOE) is a protein produced in the metabolic pathway of fats in mammals, a genotype of which seems to be related to Alzheimer's disease (AD). APOE is polymorphic and has three major alleles, $\\epsilon 2$ (e2), $\\epsilon 3$(e3), and $\\epsilon 4$ (e4). The statistics of the polymorphism are 8.4% for e2, 77.9% for e3, and 13.7% for e4 in worldwide allel frequency, respectively. It is known that the e2, e3, and e4 allels are associated with the protective factor, the neutral one, and the risk one with regard to AD. However, this finding has not been replicated in a large population. Therefore, it is known that we do not know their true associations with AD in the true population. [(from Wiki)](https://en.wikipedia.org/wiki/Apolipoprotein_E)\n        * There are 6 combinations of the genotypes:\n            * e2/e2\n            * e2/e3\n            * e2/e4\n            * e3/e3 \n            * e3/e4\n            * e4/e4\n        * In this study, I generated the 3 major alleles, e3, e4, e2\n* meta1 \\~ meta1000: a list of metabolites that were blood-sampled from the APOE carriers.\n\n:::\n\n::: {#English .tab-pane .fade role=\"tabpanel\" aria-labelledby=\"English-tab\"}\n\nSimulations were performed to outline the approximate analysis methodology. For your better understanding, I will briefly describe the simulation flow diagram. The simulation was conducted in 9 steps.\n\n#### Settings for Simulation\n\n**Data Set Size Setting**  \n\nSome of the setting values ​​required for simulation are set as global variables so that they can be freely called in the later scripts. (see @sec-global_variables)\n\n**Categorial Data Setting**\n\nI first set the dimensions of my high-dimensional data by setting the sample size and number of variables, then I created categorical data by choosing a well-known distribution, a distribution I determined, or a distribution that occurred randomly set. (see @sec-global_variables, @sec-functions, and @sec-simulation)\n\n**Sex Variable Setting**\n\nThe data of the sex variable were generated through $X \\sim \\text{Bernoulli}(0.5)$. (@sec-simulation)\n\n**Genotype Variable Setting**\n\nPersonally, I have not yet figured out how to generate data for genotype (categorical) variables statistically, so further research is needed. However, since the genetic influence on the disease should be reflected, I tried to reflect the distribution of outcome variables and well-known distribution of the genotypes, APOE [(from Wiki)](https://en.wikipedia.org/wiki/Apolipoprotein_E). To make an association between the two variables, the proportions of each variable were set as marginal distirubtion and the joint distribution of the two variables was calculated to generate genotype data. (@sec-functions and @sec-simulation)\n\n**Metabolite Data Setting**\n\nAs a setting for generating high-dimensional metabolomic data, a covariance matrix generated by random numbers is generated to create high-dimensional and mutually correlated metabolites within a group, which is used as input in the MVN (Multivariate Normal Distribution) function, and for each group, the metabolites' effect (or weight) toward the outcome variable is also set to be randomly generated with a random number. At this time, the range of numbers randomly generated by random numbers was arbitrarily limited by myself. A seed number was fixed for reproducibility. (@sec-simulation)\n\n**Outcome Variable Setting**\n\nA score matrix was created through the matrix multiplication of the data created by MVN and a pre-made weight matrix with the probability values of samples that were created using the Logit Link. Based on the probability value of each sample, a binary outcome variable representing disease status information was created through $X \\sim \\text{Bernoulli}(p)$, (where $p$ means the probability value of each sample). (@sec-simulation)\n\n**Age Variable Setting**\n\nSince the Age variable is a important factor related to dementia biologically and medically, the metabolite best explained as an Outcome variable was selected and converted into an age scale using min-max normalization by setting the youngest to 65 and the oldest to 105. (@sec-functions and @sec-simulation)\n\n**Merge All Data**\n\nEach variable created through simulation was merged into a data frame. (@sec-simulation)\n\n**Analytics & Conclusion**\n\nThe analysis part will not be discussed in detail in this data preparation section, but will be covered in detail in the EDA, Statistical Approaches and ML Approaches section. Briefly, I describe a method to identify the variables most associated with the outcome variable by selecting metabolites that have a statistically significant relationship with the outcome variable and comparing how similar the results are to those obtained through machine learning.\n\n\n\n::: {.cell}\n\n:::\n\n\n\n## Simulation\n\n### Package Loading and Option Settings\n\n::: {.cell}\n\n```{.r .cell-code}\nif(!require(janitor)) install.packages(\"janitor\") \nif(!require(tidyverse)) install.packages(\"tidyverse\") \nif(!require(tidymodels)) install.packages(\"tidymodels\") \nif(!require(glmnet)) install.packages(\"glmnet\") \nif(!require(MASS)) install.packages(\"MASS\") \nif(!require(ggpubr)) install.packages(\"ggpubr\") \nif(!require(car)) install.packages(\"car\") \nif(!require(mixOmics)) install.packages(\"mixOmics\") \n\nlibrary(janitor)\nlibrary(tidyverse)\nlibrary(tidymodels)\nlibrary(glmnet)\nlibrary(MASS)\nlibrary(ggpubr) \nlibrary(car) \nlibrary(mixOmics)\nset.seed(20230103) \nknitr::opts_chunk$set(message=FALSE,warning=FALSE)\n```\n:::\n\n\n### Global Variables\n\n::: {.cell}\n\n```{.r .cell-code}\n# the number of samples\nsample_size <- 500 #1000\n# the number of predictors\npredictor_size <- 1000 #5000\n# the number of groups\ngroup_size <- sample(6:10,1) # at least more than 6, the number of the genotypes\n# the number of predictors truly associated with a response variable\nsignificant_predictors <- floor(predictor_size*sample((50:100)/1000,1)) \n\n## set the predictors associated with an outcome\n### the number of predictors positively associated with an outcome\n### the number of predictors negatively associated with an outcome\npositively_associated_predictors<-floor(significant_predictors*0.4) \nnegatively_associated_predictors<-significant_predictors-positively_associated_predictors \n\n## set the proportion of the groups in which the predictors are correlated with one another\n### randomly sampling proportions to become their sum equal to 1\ngroup_proportion_list<-sample(seq(1,1+2*(100-group_size)/group_size,\n                            by=2*(100-group_size)/(group_size*(group_size-1)))/100,\n                        group_size,replace=FALSE)%>%round(3) \nnames(group_proportion_list)<-paste0(\"group\",1:length(group_proportion_list))\n### initialize a matrix with a size as sample_size by predictor_size\npredictor_matrix <- matrix(0, ncol = predictor_size, nrow = sample_size)\n### initialize a data frame and assign meta information used to generate simulated data\ngroup_meta_data<-\n    data.frame(\n        group_name=c(names(group_proportion_list)),\n        proportion=group_proportion_list)%>%\n        mutate(\n            # the number of predictors within each group \n            group_n=(predictor_size*group_proportion_list)%>%round(0),\n            # the 1st index of predictors in each group \n            first_index=c(1,cumsum(group_n[-length(group_proportion_list)])+1), \n            # the last index of predictors in each group\n            last_index=cumsum(group_n),\n            # within-group correlations among the within-group predictors \n            group_correlation=sample((0:700)/1000,length(group_proportion_list),replace=TRUE), \n            # effect of each group on an outcome variable\n            group_effect=sample((-40:30)/100,length(group_proportion_list),replace=TRUE)) \n### set a group effect as 0.7 into a group with the smallest group number \ngroup_meta_data[which.min(group_meta_data[,\"group_n\"]),\"group_effect\"]<-0.7\n\n### set a group effect as -0.5 into a group with the second smallest group number \ngroup_meta_data[group_meta_data[,\"group_n\"]==(sort(group_meta_data[,\"group_n\"])[2]),\"group_effect\"]<-(-0.5)\n\n# initialize a data matrix to assign simulated values\n## add some noise to data\ndata<-matrix(rnorm(sample_size*predictor_size,mean=0,sd=0.05), \n             nrow = sample_size, ncol = predictor_size)\n\n# initialize a covariance matrix to assign simulated values\ncovariance_matrix<-matrix(rnorm(predictor_size*predictor_size,mean=0,sd=0.05),\n                          nrow=predictor_size, ncol=predictor_size)\nbeta_coefficients <- rnorm(predictor_size,0,0.05)\n\nanswer_list<-list(\n    'sample size'=sample_size,\n    'predictor size'=predictor_size,\n    'group size'=group_size,\n    'significant predictors'=significant_predictors,\n    'positively associated predictors'=positively_associated_predictors,\n    'negatively associated predictors'=negatively_associated_predictors,\n    'group proportion list'=group_proportion_list,\n    'group meta data'=group_meta_data,\n    'data noise intensity'=c('distribution'='rnorm','mean'=0,'sd'=0.05),\n    'covariance noise intensity'=c('distribution'='rnorm','mean'=0,'sd'=0.05),\n    'effect noise intensity on response'=c('distribution'='rnorm','mean'=0,'sd'=0.05),\n    'link function between the response and predictors' = 'canonical logit link function',\n    'link function noise intensity' = c('distribution'='rnorm','mean'=0,'sd'=0.05),\n    'age_distirbution'='used data of a variable with the highest effect on outcome',\n    'sex_distribution'='rbinom(n=sample size,p=0.5)',\n    'genotype_distirbution'=c('e2' = '8.4%','e3' = '77.9%','e4' = '13.7%'))\n```\n:::\n\n\n### Functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Function List\n\nscale_function=function(vector=x,min=a,max=b,method=\"customized\"){\n    if(method==\"min-max\"){\n        result=(vector-min(vector))(max(vector)-min(vector))\n    }else if(method==\"customized\"){\n        result=(max-min)*(vector-min(vector))/(max(vector)-min(vector))+min\n    }else{\n        result=(vector-mean(vector))/sd(vector)\n    }\n  return(result)\n}\n\nage_data_generator=function(in_data,in_response,fun=scale_function){\n    # this function generates a age (continuous) data that are statistically associated \n    # with a simulated variable as designed above.\n\n    ## conduct t test with the response and each variable generated by multivariate normal distributions.\n    ## search a variable with the largest difference in mean between the two groups or with the lowest p value\n    ## In this case, I will pick the former one. \n    ## (I don't care about the multiple testing problems for now)\n    temp_df=as.data.frame(matrix(ncol=5)) # initialize an empty data frame\n    for(i in 1:ncol(in_data)){\n        temp_df[i,]=c(\n            names(in_data)[i],\n            t.test(in_data[,i]~in_response)$estimate[1],\n            t.test(in_data[,i]~in_response)$estimate[2],\n            t.test(in_data[,i]~in_response)$estimate[2]-t.test(data[,i]~response)$estimate[1],\n            t.test(in_data[,i]~in_response)$p.value)\n    }\n    names(temp_df)<-c('metabolite','mean_neg','mean_pos','mean_diff','p.value')\n\n    ## search a variable with the largest difference in mean\n    strong_metabolite<-\n        temp_df%>%\n        mutate(\n            mean_neg=as.numeric(mean_neg),\n            mean_pos=as.numeric(mean_pos),\n            mean_diff=as.numeric(mean_diff),\n            p.value=as.numeric(p.value),\n            abs_mean_diff=abs(mean_diff))%>%\n        filter(abs_mean_diff==max(abs_mean_diff))%>%\n        dplyr::select(metabolite)%>%pull\n    \n    ## generate age data with min max normalization\n    age_data<-\n        data%>%\n        dplyr::select(strong_metabolite)%>%\n        scale_function(vector=.,min=65,max=105,method=\"customized\")%>%\n        rename(age=1)%>%round(0)\n    return(age_data)\n}\n\n\ngenotype_data_generator=function(in_response=response,fun=scale_function){\n    # this function generates a genotype (categorical) data \n    # that are jointly and statistically associated with a continuous data and a binary data \n    # (I am not so sure if I can generate data that are statistically associated \n    # with some fake metabolite data. But, I will give it a try).\n\n    ## Declare the marginal proportions \n    ## for binary (affected vs unaffected) and a genotype (categorical) data, respectively\n\n    ##the simulated proportion for the disease vs non-disease cases\n    binary_proportion<-as.numeric(table(in_response)/sample_size) \n    genotype_proportion<-c(0.084,0.779,0.137) # the known proportion of APOE genotypes from Wiki\n\n    ## Declare the joint proportion predictor matrix\n    joint_proportion<-matrix(\n        c(binary_proportion[1]*genotype_proportion, # for the unaffected cases\n        binary_proportion[2]*genotype_proportion),  # for the affected cases\n        ncol=2, byrow=FALSE)\n\n    # Generate the genotype (catogrical) data\n    genotype_data = numeric(sample_size) # initialize a vector \n    for (i in 1:sample_size) {\n        genotype_data[i] = sample(\n            c('e2','e3','e4'),\n             1, \n             prob=joint_proportion[,ifelse(grepl('neg',in_response[i]),1,2)])\n    }    \n    return(genotype_data)\n}\n```\n:::\n\n\n\n### Simulation\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# generate simulation data using multivariate normal distribution\nfor (i in 1:nrow(group_meta_data)) {\n    \n    group_range <- group_meta_data[i, \"first_index\"]:group_meta_data[i, \"last_index\"]\n    for (j in group_range){\n        for(k in group_range){\n        covariance_matrix[j, k] <- group_meta_data[i, \"group_correlation\"]\n        }\n    }\n    #covariance_matrix[group_range, group_range]+group_meta_data[i, \"group_correlation\"]    \n    diag(covariance_matrix) <- 1\n    data[, group_range] <- \n        mvrnorm(n = sample_size, \n                mu = rep(0,group_meta_data[i,\"group_n\"]),\n                Sigma = covariance_matrix[group_range, group_range])\n    data=as.data.frame(data)\n    beta_coefficients[group_meta_data[i, \"first_index\"]:group_meta_data[i, \"last_index\"]] <-\n        beta_coefficients[group_meta_data[i, \"first_index\"]:group_meta_data[i, \"last_index\"]]+\n        group_meta_data[i,\"group_effect\"]\n    predictor_names<-paste0(group_meta_data[i,\"group_name\"],\"_\",1:group_meta_data[i,\"group_n\"])\n    names(beta_coefficients)[group_meta_data[i, \"first_index\"]:group_meta_data[i, \"last_index\"]] <- predictor_names\n    names(data)[group_meta_data[i, \"first_index\"]:group_meta_data[i, \"last_index\"]]<-predictor_names\n        \n}\nscore=as.matrix(data)%*%beta_coefficients # score of each sample\n\n# logistic function to get a probability, intercept = 0, \n## set probabilities-0.2 to apply noise and negative probabilities into 0\nprobabilities <- \n    ((1/(1+exp(-(0+score))))-rnorm(sample_size,m=0.2,sd=0.05))%>%\n    ifelse(.>1,1,.)%>%\n    ifelse(.<0,0,.)\n\nresponse <-\n    ifelse(rbinom(sample_size, 1, probabilities)==0,'negative','positive')%>%\n    factor(.,levels=c('negative','positive'))\n\n# simulate sex data\nsex_data <- rbinom(sample_size,1,0.5)\n\n# simulate age data\nage_data <- age_data_generator(in_data=data,in_response=response)\n\n# simulate genotype data\ngenotype_data <- genotype_data_generator(in_response=response)\n\n# merge the univariables\nphenotype_data<-\n    data.frame(\n        id=1:sample_size,\n        outcome=response,\n        age=age_data,\n        sex=sex_data,\n        genotype=genotype_data)\n\nall_data=inner_join(\n    phenotype_data,\n    data%>%mutate(id=1:n()),\n    by=\"id\")\n\n#write_rds(all_data,\"./docs/data/llfs_simulated_data.rds\")\n```\n:::\n\n\n### Load Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load simulation data\nsimulated_data<-read_rds(datapath)\n\n# simple data pre-processing\nall_data<-\n    simulated_data%>%\n    mutate(\n      outcome=factor(outcome,levels=c(\"negative\",\"positive\")),\n      sex=ifelse(sex==0,\"man\",\"woman\"),\n      sex=factor(sex,levels=c(\"man\",\"woman\")),\n      genotype=factor(genotype,levels=c(\"e3\",\"e2\",\"e4\"))\n      )\n\n# rename metabolite variables\nnames(all_data)[6:ncol(all_data)]<-paste0(\"meta\",1:predictor_size)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n## Data Description\n\nThis data include 500 samples and 1005 variables:\n\n* id: sample ID.\n* outcome: a disease status (positive, negative), positive is an affected status, negative is an unaffected status, and the reference group is positive.\n* age: age\n* sex: sex (man, woman) and the reference group is man.\n* genotype: APOE genotypes\n    * the apolipoprotein $\\epsilon$ (APOE) is a protein produced in the metabolic pathway of fats in mammals, a genotype of which seems to be related to Alzheimer's disease (AD). APOE is polymorphic and has three major alleles, $\\epsilon 2$ (e2), $\\epsilon 3$(e3), and $\\epsilon 4$ (e4). The statistics of the polymorphism are 8.4% for e2, 77.9% for e3, and 13.7% for e4 in worldwide allel frequency, respectively. It is known that the e2, e3, and e4 allels are associated with the protective factor, the neutral one, and the risk one with regard to AD. However, this finding has not been replicated in a large population. Therefore, it is known that we do not know their true associations with AD in the true population. [(from Wiki)](https://en.wikipedia.org/wiki/Apolipoprotein_E)\n        * There are 6 combinations of the genotypes:\n            * e2/e2\n            * e2/e3\n            * e2/e4\n            * e3/e3 \n            * e3/e4\n            * e4/e4\n        * In this study, I generated the 3 major alleles, e3, e4, e2\n* meta1 \\~ meta1000: a list of metabolites that were blood-sampled from the APOE carriers.\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}