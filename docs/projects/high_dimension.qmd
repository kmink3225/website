---
title: "Comparative Study of Dimension Reduction Methods"
subtitle: "Statistics and Machine Learning"
description: "Due to security concerns, it is difficult to display the data used in this project. Therefore, we will generate fake data to reproduce and demonstrate a rough analysis pipeline."
author: Kwangmin Kim
date: 2022-12-10
image: images/high_dimensions.jpg
image-alt: "a high dimensional data"
---

## Introduction

### Rationale

### Goal

## Data Preparation

### Package Loading and Option Settings

```{r, echo=FALSE,message=FALSE,warning=FALSE}

library(tidyverse)
library(tidymodels)
library(glmnet)
library(MASS)
#library(mixOmics)
set.seed(20221213) 

```

```{r}

# the number of samples
sample_size <- 500
# the number of predictors
predictor_size <- 500
group_size <- 5
# the number of predictors truly associated with a response variable
significant_predictors <- floor(predictor_size*sample((50:200)/1000,1)) 

## set the predictors associated with an outcome
### the number of predictors positively associated with an outcome
### the number of predictors negatively associated with an outcome
positively_associated_predictors<-floor(significant_predictors*0.4) 
negatively_associated_predictors<-significant_predictors-positively_associated_predictors 

## set correlated predictors within each group
### randomly sampling proportions of 10 correlated predictor groups 
### to become their sum equal to 1
proportion_list<-sample(seq(1,1+2*(100-group_size)/group_size,
                            by=2*(100-group_size)/(group_size*(group_size-1)))/100,
                        group_size,replace=FALSE)%>%round(3) 
names(proportion_list)<-paste0("group",1:length(proportion_list))
### initialize a matrix with a size as sample_size by predictor_size
predictor_matrix <- matrix(0, ncol = predictor_size, nrow = sample_size)
### initialize a data frame and assign meta info used to generate simulated data
meta_data<-
    data.frame(group_name=c(names(proportion_list)),
               proportion=proportion_list)%>%
    mutate(group_n=(predictor_size*proportion_list)%>%round(0), # the within-group number of predictors
           first_index=c(1,cumsum(group_n[-length(proportion_list)])+1), # the 1st index of predictors in each group
           last_index=cumsum(group_n), # the last index of predictors in each group
           group_correlation=sample((0:700)/1000,length(proportion_list),replace=TRUE), # correlation among the within-group predictors
           group_effect=sample((-500:500)/1000,length(proportion_list),replace=TRUE)); # effect of each group on an outcome variable


data<-matrix(rnorm(sample_size*predictor_size,mean=0,sd=0.01), 
             nrow = sample_size, ncol = predictor_size)
covariance_matrix<-matrix(rnorm(predictor_size*predictor_size,0.15,0.05),
                          nrow=predictor_size, ncol=predictor_size)
beta_coefficients <- rnorm(predictor_size,0,0.1)%>%vector()


for (i in 1:nrow(meta_data)) {
    
    group_range <- meta_data[i, "first_index"]:meta_data[i, "last_index"]
    for (j in group_range){
        for(k in group_range){
        covariance_matrix[j, k] <- meta_data[i, "group_correlation"]
        }
    }
    #covariance_matrix[group_range, group_range]+meta_data[i, "group_correlation"]    
    diag(covariance_matrix) <- 1
    data[, group_range] <- 
        mvrnorm(n = sample_size, 
                mu = rep(0,meta_data[i,"group_n"]),
                Sigma = covariance_matrix[group_range, group_range])
    
    beta_coefficients[meta_data[i, "first_index"]:meta_data[i, "last_index"]] <-
        beta_coefficients[meta_data[i, "first_index"]:meta_data[i, "last_index"]]+
        meta_data[i,"group_effect"]
    variable_names<-paste0(meta_data[i,"group_name"],"_",1:meta_data[i,"group_n"])
    names(beta_coefficients[meta_data[i, "first_index"]:meta_data[i, "last_index"]]) <- variable_names 
        
}


```

```{r}
# prepare phenotype data

age_distribution=rchisq(500,df=10)
sex_distribution=sample(c(0,1),500,replace=TRUE,prob = c(0.45,0.55))
country_distribution=sample(c(0:3),500,replace=TRUE,prob = c(0.3,0.2,0.2,0.3))
treatment_distribution=sample(c(0:2),500,replace=TRUE,prob = c(0.7,0.1,0.2))
genotype_distribution=sample(c(0:5),500,replace=TRUE,
                             prob = c(0.05,0.15,0.05,0.40,0.25,0.1))


pheno_type<-
    data.frame(
        age=sapply(age_distribution,
                   function(x)(x-min(age_distribution))/(max(age_distribution)-
                    min(age_distribution))*(105-65)+65)%>%round(0),
        sex=sex_distribution,
        country=country_distribution,
        treatment=treatment_distribution,
        genotype=genotype_distribution)%>%
    mutate(age=ifelse(genotype==0,age+3,
                      ifelse(genotype==1,age+2,
                             ifelse(genotype==4,age-1,
                                    ifelse(genotype==5,age-2,age)))),
           age=age+rnorm(sample_size,mean=0,sd=2),
           age=round(age,0))%>%
    mutate(age=ifelse(sex==0,age-3,age))

phenotype_variable="age"
standarization_function=function(phenotype_variable){
    temp=pheno_type[,phenotype_variable]
    return(sapply(temp,function(x)(x-mean(temp))/sd(temp)))
}
    
?mvnorm

y <- apply(x[,1:significant_variables], 1, function(x)sum(x)) + 
    rnorm(sample_size) + 
    standarization_function("age")+
    standarization_function("sex")


pheno_type%>%group_by(genotype)%>%summarise(mean=mean(age),sd=sd(age))
pheno_type%>%names()


```

## Data Description

## Architecture of Analysis Pipeline

## Methods

```{r, echo=FALSE,message=FALSE,warning=FALSE}
n <- 1000    # sample size
p <- 10000     # the number of predictors
significant_p <- p*0.25  # the number of predictors associated with a response variable

x <- matrix(rnorm(n*p), nrow=n, ncol=p)
y <- apply(x[,1:significant_p], 1, sum) + rnorm(n)

# Split data into train (2/3) and test (1/3) sets
train_rows <- sample(1:n, .66*n)
x.train <- x[train_rows, ]
x.test <- x[-train_rows, ]

y.train <- y[train_rows]
y.test <- y[-train_rows]

list.of.fits <- list()
for (i in 0:10) {
  fit.name <- paste0("alpha", i/10)
  
  list.of.fits[[fit.name]] <-
    cv.glmnet(x.train, y.train, type.measure="mse", alpha=i/10, 
      family="gaussian")
}

results <- data.frame()
for (i in 0:10) {
  fit.name <- paste0("alpha", i/10)
  
  predicted <- 
    predict(list.of.fits[[fit.name]], 
      s=list.of.fits[[fit.name]]$lambda.1se, newx=x.test)
  
  mse <- mean((y.test - predicted)^2)
  
  temp <- data.frame(alpha=i/10, mse=mse, fit.name=fit.name)
  results <- rbind(results, temp)
}

results
```

## Results

## Conclusion

## Bibliography
